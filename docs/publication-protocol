;;; -*- Lisp -*-
;;; $Id$
;;;
;;; Scratch pad for working out API design for RPKI engine.
;;;
;;; This file is psuedocode, I just wanted to take advantage of
;;; emacs's built-in support for languages with reasonable syntax.
;;;
;;; Terminology:
;;;
;;; - IRBE: Internet Registry Back End
;;;
;;; - RE: RPKI Engine

;;; Repository update protocol.  Same basic CMS-signed XML mess we use
;;; elsewhere, this time with RE as client, lodging repository as
;;; server.  Authorization is a combination of business key and
;;; resource key/cert: biz key demonstrates that we're authorized to
;;; play with this repository at all, resource cert demonstrates
;;; relationship to the datum to be published.

;;; This would be a trivial protocol, except for two constraints:
;;;
;;; a) In the case where parent and child are sharing a repository,
;;;    we'd like to nest child under parent to speed up rcynic.
;;;
;;; b) The repository operator might want to do some checks to assure
;;;    itself that what it's about to allow the RE to publish is not
;;;    dangerous toxic waste.
;;;
;;; Protocol goals as of last discussion in Prague:
;;;
;;; 1) "Negotiate" publication point URI.  This is a bit complex, in
;;;     that part of the URI may come from the publication
;;;     repository, parts from the RE's parent, and parts from the RE
;;;     itself.  Some discussion over whether we need online protocol
;;;     to negotiate the publication repository's part, no firm
;;;     consensus, plurality of the room was leaning towards "no",
;;;     ie, the repository's portion of the URI is negotiated via the
;;;     business channel and configured into the RE by the IRBE.
;;;
;;; 2) In case where parent and child are in fact sharing repository,
;;;    repository operator is responsible for keeping these two users'
;;;    naming schemes from coliding with each other.  More precisely,
;;;    the repository operator is responsible for checking to see that
;;;    the parent agreed to let the child publish in a particular
;;;    subtree.  Fortunately, this is an easy check: the parent has to
;;;    issue a cert to the child anyway, and that cert will contain a
;;;    signature by the parent over the child's SIA URI, so the
;;;    repository just has to check that.  For purposes of this check,
;;;    the parent's issuing cert (which the repository has, by
;;;    definition, since this is the nested hosting case) can serve as
;;;    a trust anchor for checking the child's SIA.
;;;
;;; 3) To the extent that the repository operator wants to guard
;;;    against toxic waste, it might want to check further up the
;;;    resource cert chain, regardless of where the ancestors lodge.
;;;    For this to work properly, the repository operator needs to
;;;    agree (as part of a business negotiation, probably) with the RE
;;;    on which trust anchors the repository should use to perform
;;;    these checks; ultimately, this decision (as with any TA choice)
;;;    is up to the relying party (in this case the repository
;;;    operator), but if there's going to be a problem due to
;;;    mismatched TA choices, we would really like to throw the
;;;    exception during the business negotiation rather than via a
;;;    runtime refusal to publish.
;;;
;;; Note that, in this publication model, any agreement that the
;;; repository makes to publish the RE's output is conditional upon
;;; the object to be published passing all of its checks.

;;; While there has been some discussion of using the CMS "bag of
;;; certs" mechanism to include resource certs and avoid inventing yet
;;; another encapsulation protocol, the text below assumes that we are
;;; using CMS-wrapped XML in the same way here as in the other
;;; protocols in this set: the CMS wrapper includes a signature based
;;; on a business key and the certs necessary to verify that business
;;; key, but all other data is within an XML wrapper contained in the
;;; eContent OCTET STRING of the CMS message.

(publish-thing :publication-uri uri-of-thing-we-are-publishing
	       :signed-thing signed-thing
	       :credential-certs (cert ....)
	       :thing-type :crl)
=> ()

;;; signed-thing is an object (certificate, CRL, ROA) signed by the
;;; private key associated with a resource certificate held by the
;;; entity sending the (publish-thing) request.
;;;
;;; credential-certs is a set of whatever resource certificates are
;;; needed to demonstrate to the repository engine that the entity
;;; requesting publication is making a legitimate publication request.
;;; Goal (2), above, requires the requestor to supply the resource
;;; certificate chain up to the parent to demonstrate that the parent
;;; has approved (signed) the requested SIA.  Goal (3), above, would
;;; require supplying the cert chain back to some resource trust
;;; anchor established as part of the business relationship between
;;; requestor and repository operator.
;;;
;;; Thing type...was present in a previous version of this protocol.
;;; I'm not sure we need it, am not sure we don't.

;;; A previous version of this document suggested that if we always
;;; pass up the certificate that signed the object we're trying to
;;; publish, the SIA pointer in that cert would tell the repository
;;; engine the URI at which we wanted this object to be published.
;;; This could work (and might allow us to get away from the XML
;;; wrapper entirely), but is a bit contorted.  The signer's SIA would
;;; tell us the directory in which to place this object, but does not
;;; tell us the filename for the object itself.  We could derived the
;;; filename from the g(ski) algorithm, but that assumes we're willing
;;; to accept that as the one true naming scheme for purposes of this
;;; publication protocol.

-*- Text -*- $Id$

"Cynical rsync" -- fetch and validate RPKI certificates.

This is the C implementation.  It's still rough in places, but it
appears to work, and at least for the current test data available from
APNIC and RIPE it produces the same results as my Perl prototype did.

To build this you will need to link it against an OpenSSL libcrypto
that has support for the RFC 3779 extensions.  I developed this code
on FreeBSD 6-STABLE and have not (yet) tested it on any other
platform; as far as I know I have not used any seriously non-portable
features, but neither have I done a POSIX reference manual lookup for
every function call.  Please report any portability problems.

All certificates and CRLs are in DER format, with filenames derived
from the RPKI rsync URIs at which the data are published.  At some
point I'll probably write a companion program to convert a tree of DER
into the hashed directory of PEM format that most OpenSSL applications
expect.

At the moment all configuration is handled via the config file, except
for selection of the config file itself: the default is rcynic.conf,
you can override this with the -c option on the command line.  The
config file uses OpenSSL's config file syntax, and you can set OpenSSL
library configuration paramaters (eg, "engine" settings) in the config
file as well.  rcynic's own configuration parameters are in a section
called "[rcynic]".

Most configuration parameters are optional and have defaults that
should do something reasonable.  At some point I'll document them all,
once I stop fiddling with them.  For the moment, see main().

The one thing you MUST specify in the config file in order for the
program to do anything useful is file name of one or more trust
anchors.  Trust anchors for this program are represented as
DER-formated X509 objects that look just like certificates, except
that they're trust anchors.  To date I have only tested this code with
self-signed trust anchors; in theory, this is not required, in
practice the code may require tweaks to support other trust anchors.

Example of a minimal config file:

    [rcynic]

    trust-anchor.0 = trust-anchors/apnic-trust-anchor.cer
    trust-anchor.1 = trust-anchors/ripe-ripe-trust-anchor.cer
    trust-anchor.2 = trust-anchors/ripe-arin-trust-anchor.cer

By default, rcynic uses the following directories, all rooted under
the directory in which you run rcynic:

  rcynic-data/unauthenticated		Raw data fetched via rsync

  rcynic-data/authenticated		Data that rcynic has checked

  rcynic-data/authenticated.old		Saved results from immediately
					previous rcynic run, used when
					attempting to recover from
					certain kinds of errors.

rcynic copies the trust anchors themselves into the output tree with
names of the form authenticated/xxxxxxxx.n.cer, where "authenticated"
is the top of the authenticated output directory, xxxxxxxx and n are
the OpenSSL object name hash and index within the resulting virtual
hash bucket (the same as the c_hash Perl script that comes with
OpenSSL would produce), and ".cer" is the literal string ".cer".  The
reason for this is that trust anchors, by definition, are not fetched
automatically, and thus do not really have publication URIs in the
sense that every other object in these trees do.  So we use a naming
scheme which insures (a) that each trust anchor has a unique name
within the output tree and (b) that trust anchors cannot be confusd
with certificates: trust anchors always go in the top level of the
output tree, data fetched via rsync always go in subdirectories.

As currently implemented, rcynic does not attempt to maintain an
in-memory cache of objects it might need again later.  It does keep an
internal cache of the URIs from which it has already fetched data in
this pass, and it keeps a stack containing the current certificate
chain as it does its validation walk.  All other data (eg, CRLs) are
freed immediately after use and read from disk again as needed.  From
a database design standpoint, this is not very efficient, but as the
rcynic's main bottlenecks are expected to be crypto and network
operations, it seemed best to keep the design as simple as possible,
at least until execution profiling demonstrates a real issue.

To Do:

- Support for running rsync chrooted.

- Timeout hung rsync connections (see comments in code).

- Enable printout of general (not validation) OpenSSL errors?

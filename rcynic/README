-*- Text -*- 
$Id$

/*
 * Functions I'll probably need for the rest of this:
 *
 * X509_verify()	verify cert against a key (no chain)
 * X509_CRL_verify()	verify CRL against a key
 * X509_verify_cert()	verify cert against X509_STORE_CTX
 * 			(but ctx points to X509_STORE,
 * 			which points to X509_VERIFY_PARAM, ...)
 * X509_get_pubkey()	extract pubkey from cert for *_verify()
 * X509_STORE_CTX_init()	initialize ctx
 * X509_STORE_CTX_trusted_stack()  stack of trusted certs instead of
 * 				   bothering with X509_STORE
 * X509_STORE_CTX_set0_crls()	set crls
 * X509_STORE_get_by_subject()	find object in ctx/store
 *
 * We probably can't use the lookup method stuff because we're using
 * URI naming, so just load everything ourselves and don't specify any
 * lookup methods, either it works or it doesn't.  Hmm, looks like
 * X509_STORE_CTX_trusted_stack() was written for apps like this.
 *
 * Maybe we can restore stack state by using sk_dup() to save then
 * swapping to the saved stack?  Still need to clean up objects on the
 * stack, though, sk_pop_free() will get rid of everything which is
 * not what we want unless the reference counting thing bails us out.
 * Don't think the reference counts work this way.
 */

Notes on current debugging mess:

Having some trouble checking CRLs.   As far as the code itself is
concerned, we're dumping core calling X509_STORE_get_by_subject(),
because we're not using a real X509_STORE, just a trusted_stack.

But this is just the symptom.  The real issue goes deeper, and is
architectural.  We're doing a minmimal signature check on the CRL,
and accepting the CRL object if that works.  There are a bunch of
other checks we probably ought to be doing.  x509_vfy.c does them as
part of checking a certificate chain.

Arguably, the right thing to do is for us to accept a CRL
provisionally, check the cert that led us to load the CRL, and accept
the CRL if the X509_validate_cert() call on the cert checks out.

We still have a mess trying to figure out which CRL to use.  The
URI-based code knows perfectly well which one to use, but the library
is using certificate names.  If we believe that we really only care
about checking the leaf CRL at any given time, we can turn off
X509_V_FLAG_CRL_CHECK_ALL and just use X509_V_FLAG_CRL_CHECK.  For
that matter, we really only need the leaf certificate in the CRL stack
for this, so maybe we cut through all this complexity by loading the
provisional CRL into a one-entry stack each time.


Ok, so when we're looking at a certificate, we know that the
certificate's issuer is also the CRL's issuer (because the SIDR
profile says so).  We can, therefore, check signatures of both subject
certificate and CRL just by locating the issuer, which is the one
thing that the trusted_stack code does do for us (ie, we can just call
ctx.get_issuer(&issuer, &ctx, x)).  Really, we don't even need to do
that, since we have the issuer in hand when we're walking its SIA
collection anyway.

This may require a bit of reorganization, but should simplify things.

Might need to replace X509_STORE_CTX->get_crl() with something that
knows how to find our CRLs.  No, the default version calls
get_crl_sk(), which looks in X509_STORE_CTX->crls, we just need to
make sure we put the CRL(s) we want there.



Sample bare-bones rsync.conf, just lists trust anchors:

[rcynic]

trust-anchor.0	= trust-anchors/apnic-trust-anchor.cer
trust-anchor.1	= trust-anchors/ripe-ripe-trust-anchor.cer
trust-anchor.2	= trust-anchors/ripe-arin-trust-anchor.cer



Certificate and CRL checking still needs some work.  At this point it
looks like the basic sequence is always:

- Find the CRL

- Check the issuer's sig of the CRL (if hasn't already been done)

- Set up the STORE_CTX, including a single-entry stack with the CRL

- Call X509_verify_cert() and save its result

- Clean up

- Return verify result

We need this both for checking normal certs and also for checking the
CRL on a trust anchor.  The latter case may require special handling
in the verify_cb routine, but we have all the data we need for that.

May still want to check issuer's sig of subject before fetching CRL
for certs we find in the SIA collection, but that's a relatively minor
operation.   Other than that, it looks like we can isolate all the
crypto in one check_x509() [or whatever] function that we call from
the other places.  Well, ok, we probably want to leave the existing
check_crl() code alone, it's not broken.

Some of these functions probably need renaming.

Still need to clean up excessive use of STACK_OF(X509_CRL), that
should turn into a local thing within check_x509().  Might want a
cache of CRLs for eventually performance reasons, but that'd be
strictly within checking one SIA collection, and the library is not
clever enough to pick the right one out of a set on its own, so if we
were to do this the cache would have to be indexed by CRL URI.  For
the moment we're just letting the OS disk cache do that.

-*- Text -*- $Id$

"Cynical rsync" -- fetch and validate RPKI certificates.

This is the C implementation.  It's still rough in places, but it
appears to work, and at least for the current test data available from
APNIC and RIPE it produces the same results as my Perl prototype did.

To build this you will need to link it against an OpenSSL libcrypto
that has support for the RFC 3779 extensions.  I developed this code
on FreeBSD 6-STABLE and have not (yet) tested it on any other
platform; as far as I know I have not used any seriously non-portable
features, but neither have I done a POSIX reference manual lookup for
every function call.  Please report any portability problems.

All certificates and CRLs are in DER format, with filenames derived
from the RPKI rsync URIs at which the data are published.  At some
point I'll probably write a companion program to convert a tree of DER
into the hashed directory of PEM format that most OpenSSL applications
expect.

At the moment all configuration is handled via the config file, except
for selection of the config file itself: the default is rcynic.conf,
you can override this with the -c option on the command line.  The
config file uses OpenSSL's config file syntax, and you can set OpenSSL
library configuration paramaters (eg, "engine" settings) in the config
file as well.  rcynic's own configuration parameters are in a section
called "[rcynic]".

Most configuration parameters are optional and have defaults that
should do something reasonable.  At some point I'll document them all,
once I stop fiddling with them.  For the moment, see main().

The one thing you MUST specify in the config file in order for the
program to do anything useful is file name of one or more trust
anchors.  Trust anchors for this program are represented as
DER-formated X509 objects that look just like certificates, except
that they're trust anchors.  To date I have only tested this code with
self-signed trust anchors; in theory, this is not required, in
practice the code may require tweaks to support other trust anchors.

Example of a minimal config file:

    [rcynic]

    trust-anchor.0 = trust-anchors/apnic-trust-anchor.cer
    trust-anchor.1 = trust-anchors/ripe-ripe-trust-anchor.cer
    trust-anchor.2 = trust-anchors/ripe-arin-trust-anchor.cer

By default, rcynic uses the following directories, all rooted under
the directory in which you run rcynic:

  rcynic-data/unauthenticated		Raw data fetched via rsync

  rcynic-data/authenticated		Data that rcynic has checked

  rcynic-data/authenticated.old		Saved results from immediately
					previous rcynic run, used when
					attempting to recover from
					certain kinds of errors.

rcynic copies the trust anchors themselves into the output tree with
names of the form authenticated/xxxxxxxx.n.cer, where "authenticated"
is the top of the authenticated output directory, xxxxxxxx and n are
the OpenSSL object name hash and index within the resulting virtual
hash bucket (the same as the c_hash Perl script that comes with
OpenSSL would produce), and ".cer" is the literal string ".cer".  The
reason for this is that trust anchors, by definition, are not fetched
automatically, and thus do not really have publication URIs in the
sense that every other object in these trees do.  So we use a naming
scheme which insures (a) that each trust anchor has a unique name
within the output tree and (b) that trust anchors cannot be confusd
with certificates: trust anchors always go in the top level of the
output tree, data fetched via rsync always go in subdirectories.

As currently implemented, rcynic does not attempt to maintain an
in-memory cache of objects it might need again later.  It does keep an
internal cache of the URIs from which it has already fetched data in
this pass, and it keeps a stack containing the current certificate
chain as it does its validation walk.  All other data (eg, CRLs) are
freed immediately after use and read from disk again as needed.  From
a database design standpoint, this is not very efficient, but as the
rcynic's main bottlenecks are expected to be crypto and network
operations, it seemed best to keep the design as simple as possible,
at least until execution profiling demonstrates a real issue.



Usage and configuration:

Logging levels:

rcynic has its own system of logging levels, similar to what syslog()
uses but customized to the specific task rcynic performs.  Levels:

 log_sys_err		Error from operating system or library
 log_usage_err		Bad usage (local configuration error)
 log_data_err		Bad data (broken certificates or CRLs)
 log_telemetry		Normal chatter about rcynic's progress
 log_verbose		Extra verbose chatter
 log_debug		Only useful when debugging

Command line options:

 -c configfile	Path to configuration file (default: rcynic.conf)
 -l loglevel	Logging level (default: log_telemetry)
 -s		Log via syslog
 -t		Log via stdout/stderr when also using syslog
 -p		Ask syslog() to send to stderr too

Configuration file:

rcynic uses the OpenSSL libcrypto configuration file mechanism.  All
libcrypto configuration options (eg, for engine support) are
available.  All rcynic-specific options are in the "[rcynic]"
section.  You -must- have a configuration file in order for rcynic to
do anything useful, as the configuration file is the only way to list
your trust anchors.

Configuration variables:

authenticated		Path to output directory (where rcynic should
			place objects it has been able to validate).
			Default: rcynic-data/authenticated

old-authenticated	Path to which rcynic should rename the output
			directory (if any) from the previous rcynic
			run.  rcynic preserves the previous run's
			output directory both as a backup data source
			for the current run and also so that you don't
			lose all your state if rcynic chokes and
			dies.  Default: rcynic-data/authenticated.old


unauthenticated		Path to directory where rcynic should store
			unauthenticatd data retrieved via rsync.
			Unless something goes horribly wrong, you want
			rcynic to preserve and reuse this directory
			across runs to minimize the network traffic
			necessary to bring your repository mirror up
			to date.  Default: rcynic-data/unauthenticated

rsync-timeout		How long (in seconds) to let rsync run before
			terminating the rsync process, or zero for no
			timeout.  You want this timeout to be fairly
			long, to avoid terminating rsync connections
			prematurely.  It's present to let you defend
			against evil rsync server operators who try to
			tarpit your connection as a form of denial of
			service attack on rcynic.  Default: no timeout
			(but this may change, best set it explictly).


rsync-program		Path to the rsync program.  Default: rsync,
			but you should probably set this variable
			rather than just trusting the PATH environment
			variable to be set correctly.

log-level		Same as -l option on command line.  Command
			line setting overrides config file setting.
			Default: log_telemetry

use-syslog		Same as -s option on command line.  Command
			line setting overrides config file setting.
			Default: false

use-stdouterr		Same as -t option on command line.  Command
			line setting overrides config file setting.
			Default: false

syslog-perror		Same as -p option on command line.  Command
			line setting overrides config file setting.
			Default: false

syslog-facility		Syslog facility to use.  Default: local0


syslog-priority-xyz	(where xyz is an rcynic logging level, above)
			Override the syslog priority value to use when
			logging messages at this rcynic level.
			Defaults:

			syslog-priority-log_sys_err:	err
			syslog-priority-log_usage_err:	err
			syslog-priority-log_data_err:	notice
			syslog-priority-log_telemetry:	info
			syslog-priority-log_verbose:	info
			syslog-priority-log_debug:	debug



To Do:

- Support for running rsync chrooted.

  After some discussion with Randy, I've concluded that it'd be much
  simpler to run both rcynic and rsync in the chrooted jail than it
  would be to run just rsync in the chrooted jail.  As far as we can
  tell, putting rcynic in the jail with rsync doesn't create any
  serious new threats, and it simplifies many things.

  To further simplify this, we'll handle the chroot itself via an
  external program.  Wietse Venema's chrootuid[*] would probably
  suffice out of the box: one could do slightly better by tweaking it
  for this specific application, but the main thing that's missing is
  some shell script code and instructions for compiling static
  binaries and setting up the jail.  No research topics here, this is
  all ancient technology, the tricky bit is just getting all the
  finicky details right.

  [*] ftp://ftp.porcupine.org/pub/security/chrootuid1.3.tar.gz

- autoconf?  probably not, unless we run into portability issues
  serious enough to require it.

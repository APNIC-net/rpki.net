-*- Text -*- 
$Id$

/*
 * Functions I'll probably need for the rest of this:
 *
 * X509_verify()	verify cert against a key (no chain)
 * X509_CRL_verify()	verify CRL against a key
 * X509_verify_cert()	verify cert against X509_STORE_CTX
 * 			(but ctx points to X509_STORE,
 * 			which points to X509_VERIFY_PARAM, ...)
 * X509_get_pubkey()	extract pubkey from cert for *_verify()
 * X509_STORE_CTX_init()	initialize ctx
 * X509_STORE_CTX_trusted_stack()  stack of trusted certs instead of
 * 				   bothering with X509_STORE
 * X509_STORE_CTX_set0_crls()	set crls
 * X509_STORE_get_by_subject()	find object in ctx/store
 *
 * We probably can't use the lookup method stuff because we're using
 * URI naming, so just load everything ourselves and don't specify any
 * lookup methods, either it works or it doesn't.  Hmm, looks like
 * X509_STORE_CTX_trusted_stack() was written for apps like this.
 *
 * Maybe we can restore stack state by using sk_dup() to save then
 * swapping to the saved stack?  Still need to clean up objects on the
 * stack, though, sk_pop_free() will get rid of everything which is
 * not what we want unless the reference counting thing bails us out.
 * Don't think the reference counts work this way.
 */

Notes on current debugging mess:

Having some trouble checking CRLs.   As far as the code itself is
concerned, we're dumping core calling X509_STORE_get_by_subject(),
because we're not using a real X509_STORE, just a trusted_stack.

But this is just the symptom.  The real issue goes deeper, and is
architectural.  We're doing a minmimal signature check on the CRL,
and accepting the CRL object if that works.  There are a bunch of
other checks we probably ought to be doing.  x509_vfy.c does them as
part of checking a certificate chain.

Arguably, the right thing to do is for us to accept a CRL
provisionally, check the cert that led us to load the CRL, and accept
the CRL if the X509_validate_cert() call on the cert checks out.

We still have a mess trying to figure out which CRL to use.  The
URI-based code knows perfectly well which one to use, but the library
is using certificate names.  If we believe that we really only care
about checking the leaf CRL at any given time, we can turn off
X509_V_FLAG_CRL_CHECK_ALL and just use X509_V_FLAG_CRL_CHECK.  For
that matter, we really only need the leaf certificate in the CRL stack
for this, so maybe we cut through all this complexity by loading the
provisional CRL into a one-entry stack each time.


Ok, so when we're looking at a certificate, we know that the
certificate's issuer is also the CRL's issuer (because the SIDR
profile says so).  We can, therefore, check signatures of both subject
certificate and CRL just by locating the issuer, which is the one
thing that the trusted_stack code does do for us (ie, we can just call
ctx.get_issuer(&issuer, &ctx, x)).  Really, we don't even need to do
that, since we have the issuer in hand when we're walking its SIA
collection anyway.

This may require a bit of reorganization, but should simplify things.

Might need to replace X509_STORE_CTX->get_crl() with something that
knows how to find our CRLs.  No, the default version calls
get_crl_sk(), which looks in X509_STORE_CTX->crls, we just need to
make sure we put the CRL(s) we want there.

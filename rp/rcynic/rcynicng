#!/usr/bin/env python

# $Id$

"""
Reimplementation of rcynic in Python.  Work in progress.
"""

import os
import sys
import time
import shutil
import errno
import logging
import argparse
import datetime
import subprocess

import tornado.gen
import tornado.locks
import tornado.ioloop
import tornado.queues
import tornado.process

import rpki.POW
import rpki.sundial

from rpki.oids import id_kp_bgpsec_router

from lxml.etree import ElementTree, Element, SubElement, Comment

logger = logging.getLogger("rcynicng")

codes = rpki.POW.validation_status


class Status(object):
    """
    Validation status database, like validation_status_t in rcynic:tos.

    rcynic:tos version of this data structure is stored as an AVL
    tree, because the OpenSSL STACK_OF() sort-and-bsearch turned out
    to be a very poor choice for the input data.  Remains to be seen
    whether we need to do something like that here too.
    """

    db = dict()

    def __init__(self, uri):
        self.uri = uri
        self._timestamp = None
        self.status = set()

    def __str__(self):
        return "{my.timestamp} {my.uri} {status}".format(
            my = self, status = ",".join(str(s) for s in sorted(self.status)))

    @property
    def timestamp(self):
        return time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(self._timestamp))

    @classmethod
    def get(cls, uri):
        try:
            return cls.db[uri].status
        except KeyError:
            return None

    @classmethod
    def update(cls, uri):
        try:
            self = cls.db[uri]
        except KeyError:
            self = cls.db[uri] = cls(uri)
        self._timestamp = time.time()
        return self.status

    @classmethod
    def add(cls, uri, *codes):
        status = cls.update(uri)
        for code in codes:
            status.add(code)

    @classmethod
    def remove(cls, uri, *codes):
        if uri in cls.db:
            for code in codes:
                cls.db[uri].status.discard(code)

    @classmethod
    def test(cls, uri, code):
        return uri in cls.db and code in cls.db[uri].status


def install_object(obj):
    obj.obj.authenticated.add(authenticated)
    obj.obj.save()


class X509StoreCTX(rpki.POW.X509StoreCTX):

    @classmethod
    def subclass(cls, **kwargs):
        return type(cls.__name__, (cls,), kwargs)

    status = None

    def verify_callback(self, ok):
        err = self.getError()
        if err in (codes.X509_V_OK.code, codes.X509_V_ERR_SUBJECT_ISSUER_MISMATCH.code):
            return ok
        elif err == codes.X509_V_ERR_CRL_HAS_EXPIRED.code:
            return True
        elif err == codes.X509_V_ERR_UNABLE_TO_GET_ISSUER_CERT.code:
            self.status.add(codes.TRUST_ANCHOR_NOT_SELF_SIGNED)
            return ok
        else:
            self.status.add(codes.find(err))
            return ok


class X509(rpki.POW.X509):

    def __repr__(self):
        try:
            return "<X509 \"{}\" at 0x{:x}>".format(self.uri, id(self))
        except:
            return "<X509 at 0x{:x}>".format(id(self))

    @classmethod
    def store_if_new(cls, der, uri, retrieval):
        self = cls.derRead(der)
        aki  = self.getAKI()
        ski  = self.getSKI()
        return rpki.rcynicdb.models.RPKIObject.objects.get_or_create(
            der  = der,
            defaults = dict(
                uri  = uri,
                aki  = "" if aki is None else aki.encode("hex"),
                ski  = "" if ski is None else ski.encode("hex"),
                sha256 = sha256(der).encode("hex"),
                retrieved = retrieval))

    @property
    def uri(self):
        return self.obj.uri

    @property
    def aki(self):
        return self.obj.aki

    @property
    def ski(self):
        return self.obj.ski

    @classmethod
    def load(cls, obj, cms = None):
        if cms is not None:
            # XXX Kludge to work around lack of subclass support in rpki.POW.CMS.certs().
            der = cms.certs()[0].derWrite()
        else:
            der = obj.der
        self = cls.derRead(der)
        self.obj = obj
        self.bc    = self.getBasicConstraints()
        self.eku   = self.getEKU()
        self.aia   = self.getAIA()
        self.sia   = self.getSIA()
        self.crldp = self.getCRLDP()
        self.is_ca = self.bc is not None and self.bc[0]
        self.caDirectory, self.rpkiManifest, self.signedObjectRepository, self.rpkiNotify \
                          = self.sia or (None, None, None, None)
        return self

    @staticmethod
    def count_uris(uris, scheme = "rsync://"):
        count = 0
        if uris is not None:
            for uri in uris:
                if uri.startswith(scheme):
                    count += 1
        return count

    def check(self, trusted, crl):
        #logger.debug("Starting checks for %r", self)
        status = Status.update(self.uri)
        is_ta = trusted is None
        is_routercert = (self.eku is not None and id_kp_bgpsec_router in self.eku and
                         not self.is_ca and self.uri.endswith(".cer"))
        if self.eku is not None and (self.is_ca or not self.uri.endswith(".cer")):
            status.add(codes.INAPPROPRIATE_EKU_EXTENSION)
        if is_ta and not self.is_ca:
            status.add(codes.MALFORMED_TRUST_ANCHOR)
        if is_ta and self.aia is not None:
            status.add(codes.AIA_EXTENSION_FORBIDDEN)
        if not is_ta and self.aia is None:
            status.add(codes.AIA_EXTENSION_MISSING)
        if is_routercert and self.sia is not None:
            status.add(codes.SIA_EXTENSION_FORBIDDEN)
        if not is_routercert and self.sia is None:
            status.add(codes.SIA_EXTENSION_MISSING)
        if is_ta and self.crldp is not None:
            status.add(codes.CRLDP_EXTENSION_FORBIDDEN)
        if not is_ta and self.crldp is None:
            status.add(codes.CRLDP_EXTENSION_MISSING)
        if not is_ta and not self.aki:
            status.add(codes.AKI_EXTENSION_MISSING)
        elif not is_ta and self.aki != trusted[0].ski:
            status.add(codes.AKI_EXTENSION_ISSUER_MISMATCH)
        serial = self.getSerial()
        if serial <= 0 or serial > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
            status.add(codes.BAD_CERTIFICATE_SERIAL_NUMBER)
        if self.getVersion() != 2:
            status.add(codes.WRONG_OBJECT_VERSION)
        n_rsync_caIssuers              = self.count_uris(self.aia)
        n_rsync_caDirectory            = self.count_uris(self.caDirectory)
        n_rsync_rpkiManifest           = self.count_uris(self.rpkiManifest)
        n_rsync_signedObjectRepository = self.count_uris(self.signedObjectRepository)
        if n_rsync_caIssuers > 1 or n_rsync_caDirectory > 1 or n_rsync_rpkiManifest > 1 or n_rsync_signedObjectRepository > 1:
            status.add(codes.MULTIPLE_RSYNC_URIS_IN_EXTENSION)
        if self.aia is not None and n_rsync_caIssuers == 0:
            status.add(codes.MALFORMED_AIA_EXTENSION)
        if self.is_ca:
            ok = n_rsync_caDirectory != 0 and n_rsync_rpkiManifest != 0 and n_rsync_signedObjectRepository == 0
        elif not is_routercert:
            ok = n_rsync_caDirectory == 0 and n_rsync_rpkiManifest == 0 and n_rsync_signedObjectRepository != 0
        else:
            ok = self.sia is None
        if not ok:
            status.add(codes.MALFORMED_SIA_EXTENSION)
        if not is_ta and self.count_uris(self.crldp) == 0:
            status.add(codes.MALFORMED_CRLDP_EXTENSION)
        self.checkRPKIConformance(status = status, eku = id_kp_bgpsec_router if is_routercert else None)
        try:
            self.verify(trusted = [self] if trusted is None else trusted, crl = crl, policy = "1.3.6.1.5.5.7.14.2",
                        context_class = X509StoreCTX.subclass(status = status))
        except rpki.POW.ValidationError as e:
            logger.debug("%r rejected: %s", self, e)
            status.add(codes.OBJECT_REJECTED)
        codes.normalize(status)
        #logger.debug("Finished checks for %r", self)
        return not any(s.kind == "bad" for s in status)


class CRL(rpki.POW.CRL):

    def __repr__(self):
        try:
            return "<CRL \"{}\" at 0x{:x}>".format(self.uri, id(self))
        except:
            return "<CRL at 0x{:x}>".format(id(self))

    @classmethod
    def store_if_new(cls, der, uri, retrieval):
        self = cls.derRead(der)
        aki  = self.getAKI()
        return rpki.rcynicdb.models.RPKIObject.objects.get_or_create(
            der  = der,
            defaults = dict(
                uri  = uri,
                aki  = "" if aki is None else aki.encode("hex"),
                ski  = "",
                sha256 = sha256(der).encode("hex"),
                retrieved = retrieval))

    @property
    def uri(self):
        return self.obj.uri

    @property
    def aki(self):
        return self.obj.aki

    @property
    def ski(self):
        return ""

    @classmethod
    def load(cls, obj):
        self = cls.derRead(obj.der)
        self.obj = obj
        self.thisUpdate = self.getThisUpdate()
        self.nextUpdate = self.getNextUpdate()
        self.number     = self.getCRLNumber()
        return self

    def check(self, issuer):
        status = Status.update(self.uri)
        self.checkRPKIConformance(status = status, issuer = issuer)
        try:
            self.verify(issuer)
        except rpki.POW.ValidationError as e:
            logger.debug("%r rejected: %s", self, e)
            status.add(codes.OBJECT_REJECTED)
        codes.normalize(status)
        if self.getVersion() != 1:
            status.add(codes.WRONG_OBJECT_VERSION)
        now = rpki.sundial.now()
        if self.thisUpdate > now:
            status.add(codes.CRL_NOT_YET_VALID)
        if self.nextUpdate < now:
            status.add(codes.STALE_CRL_OR_MANIFEST)
        if self.number is None:
            status.add(codes.CRL_NUMBER_EXTENSION_MISSING)
        if self.number < 0:
            status.add(codes.CRL_NUMBER_IS_NEGATIVE)
        if self.number > 0x7FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF:
            status.add(codes.CRL_NUMBER_OUT_OF_RANGE)
        if self.getIssuer() != issuer.getSubject():
            status.add(codes.CRL_ISSUER_NAME_MISMATCH)
        if not self.aki:
            status.add(codes.AKI_EXTENSION_MISSING)
        elif self.aki != issuer.ski:
            status.add(codes.AKI_EXTENSION_ISSUER_MISMATCH)

        return not any(s.kind == "bad" for s in status)


class CMS_Mixin(object):

    @classmethod
    def store_if_new(cls, der, uri, retrieval):
        self = cls.derRead(der)
        cert = self.certs()[0]
        aki  = cert.getAKI()
        ski  = cert.getSKI()
        return rpki.rcynicdb.models.RPKIObject.objects.get_or_create(
            der  = der,
            defaults = dict(
                uri  = uri,
                aki  = "" if aki is None else aki.encode("hex"),
                ski  = "" if ski is None else ski.encode("hex"),
                sha256 = sha256(der).encode("hex"),
                retrieved = retrieval))

    @property
    def uri(self):
        return self.obj.uri

    @property
    def aki(self):
        return self.obj.aki

    @property
    def ski(self):
        return self.obj.ski


class Ghostbuster(rpki.POW.CMS, CMS_Mixin):

    def __repr__(self):
        try:
            return "<Ghostbuster \"{}\" at 0x{:x}>".format(self.uri, id(self))
        except:
            return "<Ghostbuster at 0x{:x}>".format(id(self))

    @classmethod
    def load(cls, obj):
        self        = cls.derRead(obj.der)
        self.obj    = obj
        self.ee     = X509.load(obj, self)
        self.vcard  = None
        return self

    def check(self, trusted, crl):
        status = Status.update(self.uri)
        self.ee.check(trusted = trusted, crl = crl)
        try:
            self.vcard = self.verify()
        except rpki.POW.ValidationError as e:
            logger.debug("%r rejected: %s", self, e)
            status.add(codes.OBJECT_REJECTED)
        self.checkRPKIConformance(status)
        codes.normalize(status)
        return not any(s.kind == "bad" for s in status)


class Manifest(rpki.POW.Manifest, CMS_Mixin):

    def __repr__(self):
        try:
            return "<Manifest \"{}\" at 0x{:x}>".format(self.uri, id(self))
        except:
            return "<Manifest at 0x{:x}>".format(id(self))

    @classmethod
    def load(cls, obj):
        self = cls.derRead(obj.der)
        self.obj = obj
        self.ee  = X509.load(obj, self)
        self.fah = None
        self.thisUpdate = None
        self.nextUpdate = None
        self.number     = None
        return self

    def check(self, trusted, crl):
        status = Status.update(self.uri)
        self.ee.check(trusted = trusted, crl = crl)
        try:
            self.verify()
        except rpki.POW.ValidationError as e:
            logger.debug("%r rejected: %s", self, e)
            status.add(codes.OBJECT_REJECTED)
        self.checkRPKIConformance(status)
        self.thisUpdate = self.getThisUpdate()
        self.nextUpdate = self.getNextUpdate()
        self.number     = self.getManifestNumber()
        self.fah        = self.getFiles()
        self.notBefore  = self.ee.getNotBefore()
        self.notAfter   = self.ee.getNotAfter()
        if self.thisUpdate < self.notBefore or self.nextUpdate > self.notAfter:
            status.add(codes.MANIFEST_INTERVAL_OVERRUNS_CERT)
        now = rpki.sundial.now()
        if self.thisUpdate > now:
            status.add(codes.MANIFEST_NOT_YET_VALID)
        if self.nextUpdate < now:
            status.add(codes.STALE_CRL_OR_MANIFEST)
        codes.normalize(status)
        return not any(s.kind == "bad" for s in status)

    def find_crl_candidate_hashes(self):
        diruri = self.uri[:self.uri.rindex("/") + 1]
        for fn, digest in self.fah:
            if fn.endswith(".crl"):
                yield digest.encode("hex")


class ROA(rpki.POW.ROA, CMS_Mixin):

    def __repr__(self):
        try:
            return "<ROA \"{}\" at 0x{:x}>".format(self.uri, id(self))
        except:
            return "<ROA at 0x{:x}>".format(id(self))

    @classmethod
    def load(cls, obj):
        self = cls.derRead(obj.der)
        self.obj = obj
        self.ee         = X509.load(obj, self)
        self.asn        = None
        self.prefixes   = None
        return self

    def check(self, trusted, crl):
        status = Status.update(self.uri)
        self.ee.check(trusted = trusted, crl = crl)
        try:
            vcard = self.verify()
        except rpki.POW.ValidationError:
            status.add(codes.OBJECT_REJECTED)
        self.checkRPKIConformance(status)
        self.asn      = self.getASID()
        self.prefixes = self.getPrefixes()
        codes.normalize(status)
        return not any(s.kind == "bad" for s in status)


class_dispatch = dict(cer = X509,
                      crl = CRL,
                      gbr = Ghostbuster,
                      mft = Manifest,
                      roa = ROA)

def uri_to_class(uri):
    cls = class_dispatch.get(uri[-3:]) if len(uri) > 4 and uri[-4] == "." else None
    if cls is None:
        Status.add(uri, None, codes.UNKNOWN_OBJECT_TYPE_SKIPPED)
    return cls


# If we find ourselves using this same ordering for every retrieval from the RPKIObjects model, we
# can add it as a Meta option for the model and omit it in the query expressions, like this:
#
#    class RPKIObjects(models.Model):
#        ...
#        class Meta:
#            ordering = ["-retrieved__started"]
#
# https://docs.djangoproject.com/en/1.8/ref/models/querysets/#order-by
# https://docs.djangoproject.com/en/1.8/ref/models/options/#django.db.models.Options.ordering

def fetch_objects(**kwargs):
    for obj in rpki.rcynicdb.models.RPKIObject.objects.filter(**kwargs).order_by("-retrieved__started"):
        cls = uri_to_class(obj.uri)
        if cls is not None:
            yield cls.load(obj)


class  WalkFrame(object):
    """
    Certificate tree walk stack frame.  This is basically just a
    preamble and a loop, broken out into several separate methods so
    that we can fork new tasks in the middle then resume processing of
    the current state machine (ie, this frame) when appropriate (eg,
    after an rsync or RRDP fetch completes).
    """

    def __init__(self, cer):
        self.cer = cer
        self.state = self.initial

    def __repr__(self):
        try:
            return "<WalkFrame \"{}\" at 0x{:x}".format(self.cer.uri, id(self))
        except:
            return "<WalkFrame at 0x{:x}>".format(id(self))

    @tornado.gen.coroutine
    def __call__(self, wsk):
        yield self.state(wsk)

    @tornado.gen.coroutine
    def initial(self, wsk):
        self.diruri  = first_rsync_uri(self.cer.caDirectory)
        self.fetcher = Fetcher(self.diruri)

        if not self.fetcher.needed():
            self.state = self.ready
        elif args.no_spawn_on_fetch:
            self.state = self.fetch
        else:
            self.state = self.fetch
            yield task_queue.put(wsk.clone())
            wsk.pop()

    @tornado.gen.coroutine
    def fetch(self, wsk):
        yield self.fetcher.fetch()
        self.state = self.ready

    @tornado.gen.coroutine
    def ready(self, wsk):
        self.trusted = wsk.trusted()

        #logger.debug("%r scanning products", self)

        # NB: CRL checks on manifest EE certificates deferred until we've picked a CRL.

        mft_candidates = []
        crl_candidates = []
        crl_candidate_hashes = set()

        for mft in fetch_objects(aki = self.cer.ski, uri__endswith = ".mft"):
            if mft.check(trusted = self.trusted, crl = None):
                mft_candidates.append(mft)
                crl_candidate_hashes.update(mft.find_crl_candidate_hashes())

        if not mft_candidates:
            wsk.pop()
            return

        for crl in fetch_objects(aki = self.cer.ski, uri__endswith = ".crl", sha256__in = crl_candidate_hashes):
            if crl.check(self.trusted[0]):
                crl_candidates.append(crl)

        mft_candidates.sort(reverse = True, key = lambda x: (x.number, x.thisUpdate, x.obj.retrieved.started))
        crl_candidates.sort(reverse = True, key = lambda x: (x.number, x.thisUpdate, x.obj.retrieved.started))

        if not crl_candidates:
            wsk.pop()
            return

        self.crl = crl_candidates[0]

        install_object(self.crl)
        Status.add(self.crl.uri, codes.OBJECT_ACCEPTED)

        #logger.debug("Picked CRL %s", self.crl.uri)

        for mft in mft_candidates:
            if self.crl.isRevoked(mft.ee):
                Status.add(mft.obj.uri, codes.MANIFEST_EE_REVOKED)
                continue
            self.mft = mft
            break
        else:
            wsk.pop()
            return

        install_object(self.mft)
        Status.add(self.mft.obj.uri, codes.OBJECT_ACCEPTED)

        self.stale_crl = Status.test(self.crl.uri, codes.STALE_CRL_OR_MANIFEST)
        self.stale_mft = Status.test(self.mft.uri, codes.STALE_CRL_OR_MANIFEST)

        # Issue warnings on mft and crl URI mismatches?

        # Use an explicit iterator so we can resume it; run loop in separate method, same reason.

        self.mft_iterator = iter(self.mft.getFiles())
        self.state        = self.loop

    @tornado.gen.coroutine
    def loop(self, wsk):

        #logger.debug("Processing %s", self.mft.uri)

        for fn, digest in self.mft_iterator:

            yield tornado.gen.moment

            uri = self.diruri + fn

            # Need general URI validator here?

            if uri == self.crl.uri:
                continue

            cls = uri_to_class(uri)

            if cls is None:
                continue

            if cls in (Manifest, CRL):
                Status.add(uri, None, codes.INAPPROPRIATE_OBJECT_TYPE_SKIPPED)
                continue

            for obj in fetch_objects(sha256 = digest.encode("hex")):
                
                # This can't happen as currently written, but we need to handle OBJECT_NOT_FOUND somehow,
                # this will do as a placeholder until we figure out how this should work.

                if obj is None:
                    Status.add(uri, codes.OBJECT_NOT_FOUND)
                    continue

                if self.stale_crl:
                    Status.add(uri, codes.TAINTED_BY_STALE_CRL)
                if self.stale_mft:
                    Status.add(uri, codes.TAINTED_BY_STALE_MANIFEST)

                if obj.check(trusted = self.trusted, crl = self.crl):
                    install_object(obj)
                    Status.add(uri, codes.OBJECT_ACCEPTED)
                    if cls is X509 and obj.is_ca:
                        wsk.push(obj)
                        return
                    break
                else:
                    Status.add(uri, codes.OBJECT_REJECTED)

        wsk.pop()


class WalkTask(object):
    """
    Task corresponding to one walk stack, roughly analgous to
    STACK_OF(walk_ctx_t) in rcynic:tos.
    """

    def __init__(self, wsk = None, cer = None):
        self.wsk = [] if wsk is None else wsk
        if cer is not None:
            self.push(cer)

    def __repr__(self):
        try:
            return "<WalkTask \"{}\" at 0x{:x}".format(self.wsk[-1].cer.uri, id(self))
        except:
            return "<WalkTask at 0x{:x}>".format(id(self))

    @tornado.gen.coroutine
    def __call__(self):
        while self.wsk:
            yield self.wsk[-1](wsk = self)

    def push(self, cer):
        self.wsk.append(WalkFrame(cer))

    def pop(self):
        return self.wsk.pop()

    def clone(self):
        return WalkTask(wsk = list(self.wsk))

    def trusted(self):
        stack = [w.cer for w in self.wsk]
        stack.reverse()
        return stack


def read_tals():
    for head, dirs, files in os.walk(args.tals):
        for fn in files:
            if fn.endswith(".tal"):
                furi = "file://" + os.path.abspath(os.path.join(head, fn))
                try:
                    with open(os.path.join(head, fn), "r") as f:
                        lines = f.readlines()
                    uri = lines.pop(0).strip()
                    b64 = "".join(lines[lines.index("\n"):])
                    key = rpki.POW.Asymmetric.derReadPublic(b64.decode("base64"))
                    if not uri.endswith(".cer"):
                        Status.add(furi, None, codes.MALFORMED_TAL_URI)
                    yield uri, key
                except:
                    Status.add(furi, None, codes.UNREADABLE_TRUST_ANCHOR_LOCATOR)


def uri_to_filename(uri, base = None):
    fn = uri[uri.index("://")+3:]
    if base is not None:
        fn = os.path.join(base, fn)
    return fn

def first_uri(uris, scheme):
    if uris is not None:
        for uri in uris:
            if uri.startswith(scheme):
                return uri
    return None

def first_rsync_uri(uris):
    return first_uri(uris, "rsync://")

def sha256(bytes):
    d = rpki.POW.Digest(rpki.POW.SHA256_DIGEST)
    d.update(bytes)
    return d.digest()


class Fetcher(object):
    """
    Network transfer methods and history database.

    At the moment this is rsync-only; eventually it will include
    support for HTTPS and RRDP.
    """

    # Internal protocol:
    #
    # - Instances which have just gotten to the query stage are not registered
    #
    # - Instances which are in progress are listed in .history and
    #   have a Condition object in .pending; instances which depend on
    #   this should wait for the condition, then return.
    #
    # - Instances which have completed are listed in .history and have
    # .pending set to None.

    _rsync_deadhosts = set()
    _rsync_history = dict()

    def __init__(self, uri):
        self.uri = uri
        self.pending = None
        self.status = None
        self.runtime = None

    def _rsync_split_uri(self):
        return tuple(self.uri.rstrip("/").split("/")[2:])

    def _rsync_find(self, path):
        for i in xrange(1, len(path)):
            target = path[:i+1]
            try:
                return self._rsync_history[target]
            except KeyError:
                continue
        return None

    def needed(self):
        if args.no_fetch:
            return False
        if self.uri.startswith("rsync://"):
            return self._rsync_needed()
        raise ValueError

    def _rsync_needed(self):
        path = self._rsync_split_uri()
        if path[0] in self._rsync_deadhosts:
            return False
        entry = self._rsync_find(path)
        return entry is None or entry.pending is not None

    def fetch(self):
        if self.uri.startswith("rsync://"):
            return self._rsync_fetch()
        raise ValueError

    @tornado.gen.coroutine
    def _rsync_fetch(self):
        assert self.uri.startswith("rsync://") and (self.uri.endswith(".cer") or self.uri.endswith("/"))

        if args.no_fetch:
            return
        path = self._rsync_split_uri()
        dead = path[0] in self._rsync_deadhosts
        other = self._rsync_find(path)
        if not dead and other is not None and other.pending is not None:
            yield other.pending.wait()
        if dead or other is not None:
            return

        self.pending = tornado.locks.Condition()
        self._rsync_history[path] = self

        try:
            path = uri_to_filename(self.uri, args.unauthenticated)
            cmd = ["rsync", "--update", "--times", "--copy-links", "--itemize-changes"]
            if self.uri.endswith("/"):
                cmd.append("--recursive")
                cmd.append("--delete")
            cmd.append(self.uri)
            cmd.append(path)

            dn = os.path.dirname(path)
            if not os.path.exists(dn):
                os.makedirs(dn)

            # We use the stdout close from rsync to detect when the  subprocess has finished.
            # There's a lovely tornado.process.Subprocess.wait_for_exit() method which does
            # exactly what one would think we'd want -- but Unix signal handling still hasn't
            # caught up to the software interrupt architecture ITS had forty years ago, so
            # signals still cause random "system call interrupted" failures in other libraries.
            # Nothing Tornado can do about this, so we avoid signals entirely and collect the
            # process exit status directly from the operating system.  In theory, the WNOHANG
            # isn't necessary here, we use it anyway to be safe in case theory is wrong.

            # If we need to add a timeout here to guard against rsync processes taking too long
            # (which has happened in the past with, eg, LACNIC), see tornado.gen.with_timeout()
            # (documented in the utility functions section of the tornado.gen page), which wraps
            # any future in a timeout.

            t0 = time.time()
            rsync = tornado.process.Subprocess(cmd, stdout = tornado.process.Subprocess.STREAM, stderr = subprocess.STDOUT)
            logger.debug("rsync[%s] started \"%s\"", rsync.pid, " ".join(cmd))
            output = yield rsync.stdout.read_until_close()
            pid, self.status = os.waitpid(rsync.pid, os.WNOHANG)
            t1 = time.time()
            self.runtime = t1 - t0
            if (pid, self.status) == (0, 0):
                logger.warn("rsync[%s] Couldn't get real exit status without blocking, sorry", rsync.pid)
            for line in output.splitlines():
                logger.debug("rsync[%s] %s", rsync.pid, line)
            logger.debug("rsync[%s] finished after %s seconds with status 0x%x", rsync.pid, self.runtime, self.status)

            # Should do something with rsync result and validation status database here.

            # We probably don't want to yield in the middle of a
            # transaction, and this doesn't really need to be wrapped
            # in a transaction in any case, so leave well enough alone.
            #
            #from django.db import IntegrityError, transaction
            #with transaction.atomic():

            retrieval = rpki.rcynicdb.models.Retrieval.objects.create(
                uri        = self.uri,
                started    = datetime.datetime.fromtimestamp(t0),
                finished   = datetime.datetime.fromtimestamp(t1),
                successful = self.status == 0)

            for fn in self._rsync_walk(path):
                yield tornado.gen.moment
                uri = "rsync://" + fn[len(args.unauthenticated):].lstrip("/")
                cls = uri_to_class(uri)
                if cls is not None:
                    try:
                        with open(fn, "rb") as f:
                            cls.store_if_new(f.read(), uri, retrieval)
                    except:
                        Status.add(uri, codes.UNREADABLE_OBJECT)
                        logger.exception("Couldn't read %s from rsync tree", uri)

        finally:
            pending = self.pending
            self.pending = None
            pending.notify_all()

    def _rsync_walk(self, path):
        if self.uri.endswith("/"):
            for head, dirs, files in os.walk(path):
                for fn in files:
                    yield os.path.join(head, fn)
        elif os.path.exists(path):
            yield path


class CheckTALTask(object):

    def __init__(self, uri, key):
        self.uri = uri
        self.key = key

    def __repr__(self):
        return "<CheckTALTask: \"{}\">".format(self.uri)

    @tornado.gen.coroutine
    def __call__(self):
        yield Fetcher(self.uri).fetch()
        for cer in fetch_objects(uri = self.uri):
            if self.check(cer):
                yield task_queue.put(WalkTask(cer = cer))
                break
        else:
            Status.add(self.uri, codes.TRUST_ANCHOR_SKIPPED)

    def check(self, cer):
        if self.key.derWritePublic() != cer.getPublicKey().derWritePublic():
            Status.add(self.uri, codes.TRUST_ANCHOR_KEY_MISMATCH)
            ok = False
        else:
            ok = cer.check(trusted = None, crl = None)
        if ok:
            install_object(cer)
            Status.add(self.uri, codes.OBJECT_ACCEPTED)
        else:
            Status.add(self.uri, codes.OBJECT_REJECTED)
        return ok


@tornado.gen.coroutine
def worker(meself):
    #
    # NB: This particular style of control loop REQUIRES an except
    #     clause, even if that except clause is just a pass statement.
    #
    while True:
        task = yield task_queue.get()
        try:
            logger.debug("Worker %s starting %s, queue length %s", meself, task, task_queue.qsize())
            yield task()
        except:
            logger.exception("Worker %s caught unhandled exception from %s", meself, task)
        finally:
            task_queue.task_done()
            logger.debug("Worker %s finished %s, queue length %s", meself, task, task_queue.qsize())


def final_report():
    # Clean up a bit to avoid confusing the user unnecessarily.
    for s in Status.db.itervalues():
        if codes.OBJECT_ACCEPTED in s.status:
            s.status.discard(codes.OBJECT_REJECTED)
    doc = Element("rcynic-summary") # rcynic-version = "", summary-version = "", reporting-hostname = ""
    labels = SubElement(doc, "labels")
    for code in codes.all():
        SubElement(labels, code.name).text = code.text
    for uri in Status.db:
        for sym in sorted(Status.db[uri].status):
            SubElement(doc, "validation_status",
                       timestamp  = str(Status.db[uri].timestamp),
                       status     = str(sym),
                       generation = "None"              # Historical relic, remove eventually
                       ).text     = uri
    #
    # Should generate <rsync_history/> elements here too, later
    #
    ElementTree(doc).write(file = args.xml_file, pretty_print = True)


@tornado.gen.coroutine
def launcher():
    for i in xrange(args.workers):
        tornado.ioloop.IOLoop.current().spawn_callback(worker, i)

    yield [task_queue.put(CheckTALTask(uri, key)) for uri, key in read_tals()]
    yield task_queue.join()


class posint(int):
    def __init__(self, value):
        if self <= 0:
            raise ValueError


def main():
    os.environ.update(TZ = "UTC",
                      DJANGO_SETTINGS_MODULE = "rpki.django_settings.rcynic")
    time.tzset()

    parser = argparse.ArgumentParser(description = __doc__)

    parser.add_argument("--authenticated",      default = "rcynic-data/authenticated")
    parser.add_argument("--unauthenticated",    default = "rcynic-data/unauthenticated")
    parser.add_argument("--xml-file",           default = "rcynicng.xml",       type = argparse.FileType("w"))

    parser.add_argument("--tals",               default = "sample-trust-anchors")

    parser.add_argument("--workers",            type = posint, default = 10)

    parser.add_argument("--no-fetch",           action = "store_true")
    parser.add_argument("--no-spawn-on-fetch",  action = "store_true")
    parser.add_argument("--no-migrate",         action = "store_true")

    global args
    args = parser.parse_args()

    import django
    django.setup()

    if not args.no_migrate:
        # Not sure we should be doing this on every run, but sure simplifies things.
        import django.core.management
        django.core.management.call_command("migrate", verbosity = 0, interactive = False)

    global rpki
    import rpki.rcynicdb

    logging.basicConfig(level = logging.DEBUG, format = "%(asctime)s  %(message)s", datefmt = "%Y-%m-%d %H:%M:%S")

    global authenticated
    authenticated = rpki.rcynicdb.models.Authenticated.objects.create(started  = datetime.datetime.now())

    global task_queue
    task_queue = tornado.queues.Queue()
    tornado.ioloop.IOLoop.current().run_sync(launcher)

    final_report()

    authenticated.finished = datetime.datetime.now()
    authenticated.save()


if __name__ == "__main__":
    main()

#!/usr/bin/env python

# $Id$

"""
Reimplementation of rcynic in Python.  Work in progress.

Well, OK, at the moment this doesn't even come close to being a
replacement for the C version of rcynic, must less adding the new
features that were the reason for bothering with all this.  Right now,
this is just a test framework for the new POW.c code to support Python
RP code.  Gotta start somewhere.
"""

import os
import sys
import time
import argparse

import rpki.POW

from lxml.etree import ElementTree, Element, SubElement, Comment

class Status(object):
    """
    Validation status database, like validation_status_t in rcynic:tos.
    """

    db = dict()

    def __init__(self, uri, generation = None):
        assert generation in ("current", "backup", None)
        self.uri = uri
        self.generation = generation
        self.timestamp = None
        self.status = set()

    def __str__(self):
        return "{time} {self.uri} {status} {self.generation}".format(
            self   = self,
            time   = time.strftime("%Y-%m-%dT%H:%M:%SZ", time.gmtime(self.timestamp)),
            status = ",".join(str(s) for s in sorted(self.status)))

    @classmethod
    def update(cls, uri, generation = None):
        try:
            key  = (uri, generation)
            self = cls.db[key]
        except KeyError:
            self = cls.db[key] = cls(uri, generation)
        self.timestamp = time.time()
        return self.status


def parse_arguments():

    def check_dir(s):
        if not os.path.isdir(s):
            raise argparse.ArgumentTypeError("%r is not a directory" % s)
        return s

    parser = argparse.ArgumentParser(description = __doc__)
    parser.add_argument("--unauthenticated",   type = check_dir, default = "rcynic-data/unauthenticated")
    parser.add_argument("--old-authenticated", type = check_dir, default = "rcynic-data/authenticated.old")
    parser.add_argument("--tals",              type = check_dir, default = "sample-trust-anchors")
    parser.add_argument("--output",                              default = "rcynic-data/rcynicng-output")
    return parser.parse_args()


def read_tals():
    for root, dirs, files in os.walk(args.tals):
        for fn in files:
            if fn.endswith(".tal"):
                furi = "file://" + os.path.abspath(os.path.join(root, fn))
                try:
                    with open(os.path.join(root, fn), "r") as f:
                        lines = f.readlines()
                    uri = lines.pop(0).strip()
                    b64 = "".join(lines[lines.index("\n"):])
                    key = rpki.POW.Asymmetric.derReadPublic(b64.decode("base64"))
                    if not uri.endswith(".cer"):
                        Status.update(furi).add(rpki.POW.validation_status.MALFORMED_TAL_URI)
                    yield uri, key
                except:
                    Status.update(furi).add(rpki.POW.validation_status.UNREADABLE_TRUST_ANCHOR_LOCATOR)


def uri_to_filename(uri, base = None):
    fn = uri[uri.index("://")+3:]
    if base is not None:
        fn = os.path.join(base, fn)
    return fn

def uri_to_basename(uri):
    return uri.rpartition("/")[2]

def first_uri(uris, scheme):
    for uri in uris:
        if uri.startswith(scheme):
            return uri
    return None

def first_rsync_uri(uris):
    return first_uri(uris, "rsync://")

def sha256(bytes):
    d = rpki.POW.Digest(rpki.POW.SHA256_DIGEST)
    d.update(bytes)
    return d.digest()


def walk_tree(cauri, ca, trusted, crl, basedir):
    trusted.insert(0, ca)

    sia    = ca.getSIA()
    diruri = first_rsync_uri(sia[0])
    mfturi = first_rsync_uri(sia[1])
    try:
        mft = rpki.POW.Manifest.derReadFile(uri_to_filename(mfturi, basedir))
    except rpki.POW.Error as e:
        print mfturi, e
        return
    ee     = mft.certs()[0]
    crldp  = ee.getCRLDP()
    crluri = first_rsync_uri(crldp)
    try:
        crl = rpki.POW.CRL.derReadFile(uri_to_filename(crluri, basedir))
    except rpki.POW.Error as e:
        print crluri, e
        return

    crl_status = Status.update(crluri)
    crl.verify(ca, crl_status)

    mft_status = Status.update(mfturi)
    ee.verify(trusted = trusted, crl = crl, status = mft_status)
    mft.verify(status = mft_status)

    crl_status.add(rpki.POW.validation_status.CRL_NOT_IN_MANIFEST)

    for fn, digest in mft.getFiles():
        uri = diruri + fn
        status = Status.update(uri)

        if uri == crluri:
            if digest != sha256(crl.derWrite()):
                status.add(rpki.POW.validation_status.DIGEST_MISMATCH)
            status.remove(rpki.POW.validation_status.CRL_NOT_IN_MANIFEST)
            continue

        with open(os.path.join(uri_to_filename(diruri, basedir), fn), "rb") as f:
            der = f.read()
        if sha256(der) != digest:
            status.add(rpki.POW.validation_status.DIGEST_MISMATCH)

        if fn.endswith(".roa"):
            roa = rpki.POW.ROA.derRead(der)
            ee = roa.certs()[0]
            ee.verify(trusted = trusted, crl = crl, status = status)
            roa.verify(status = status)
            continue

        if fn.endswith(".gbr"):
            gbr = rpki.POW.CMS.derRead(der)
            ee = gbr.certs()[0]
            ee.verify(trusted = trusted, crl = crl, status = status)
            vcard = gbr.verify(status = status)
            continue

        if fn.endswith(".cer"):
            cer = rpki.POW.X509.derRead(der)
            cer.verify(trusted = trusted, crl = crl, status = status)
            is_ca = (cer.getBasicConstraints() or (False, None))[0]
            if is_ca:
                walk_tree(diruri + fn, cer, trusted, crl, basedir)
            continue

        status.add(rpki.POW.validation_status.UNKNOWN_OBJECT_TYPE_SKIPPED)


os.putenv("TZ", "UTC")
time.tzset()

args = parse_arguments()

basedir = args.unauthenticated

for uri, key in read_tals():
    status = Status.update(uri)
    status.add(rpki.POW.validation_status.OBJECT_REJECTED)
    try:
        cer = rpki.POW.X509.derReadFile(uri_to_filename(uri, basedir))
    except rpki.POW.OpenSSLError:
        status.add(rpki.POW.validation_status.UNREADABLE_TRUST_ANCHOR)
        continue
    if key.derWritePublic() != cer.getPublicKey().derWritePublic():
        status.add(rpki.POW.validation_status.TRUST_ANCHOR_KEY_MISMATCH)
        continue
    trusted = [cer]
    try:
        cer.verify(trusted = trusted, status = status)
    except:
        continue
    else:
        status.remove(rpki.POW.validation_status.OBJECT_REJECTED)
    walk_tree(uri, cer, trusted, None, basedir)

for uri in sorted(Status.db):
    print Status.db[uri]

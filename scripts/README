$Id$

Python RPKI production tools.

Requires Python 2.5.

External Python packages required:

- lxml, which in turn requires the libxml2 C libraries.

  FreeBSD: /usr/ports/devel/py-lxml

- MySQLdb, which in turn requires MySQL client and server.  I'm
  testing with MySQL 5.1.

  FreeBSD: /usr/ports/databases/py-MySQLdb

- TLSLite, which pulls in other crypto packages.

  FreeBSD: /usr/ports/security/py-tlslite

- Cryptlib, at the moment just to support TLSlite but may end up using
  it for other things later.

  FreeBSD: /usr/ports/security/cryptlib

  ...but the FreeBSD port doesn't (yet?) install the Python bindings,
  sigh, so at the moment you have to do that by hand:

  # cd /usr/ports/security/cryptlib
  # make install
  # cd work/bindings
  # python setup.py install
  # cd ../..
  # make clean

- Eventually I expect that this will require an event-handling package
  like Twisted, but I'm not there yet.

- The testpoke tool (up-down protocol command line test client) also
  uses PyYAML, mostly for compatability with APNIC's equivalent tool.

  FreeBSD: /usr/ports/devel/py-yaml

We also use a hacked copy of the Python OpenSSL Wrappers (POW)
package, but our copy has enough modifications that it's expanded in
the Subversion tree.  Depending on how this all works out, I may end
up splitting the POW.pkix module out of the POW package and using it
with Cryptlib, as the POW.pkix package is 98% about doing ASN.1 in
pure Python and only 2% about any kind of crypto.



To do list:

- timestamps are a mess.  we have four different kinds already:
  seconds from epoch, the the two flavors of timestamps used
  in asn.1, and the timestamps used in mysql.  need a
  unifying class to hide all this nastiness.

- publication protocol and implementation

- manifest generation

- subsetting (req_* attributes in up-down protocol)

- revocation and crl generation

  - need to keep data on unexpired revoked certs to generate crl

  - ever need to delay revocation of old certs to give their
  replacements time to propegate?

  these two may imply that we need more fields in child_cert table to
  indicate whether a cert is dead, eg, a date field which is NULL if
  the cert is still live, otherwise is the date after which it should
  be in the crl

- publication hooks everywhere - need not wait for protocol, can just
  log what would happen for now

  - cert publication

  - crl publication

  - manifest publication

  - withdrawal of all of the above

- child batch processing loop, eg, regeneration or removal of expired
  certs, crl and manifest update, etc

  hmm, should this be an iteration over child_cert objects or over ca
  objects?  probably the latter as the ca is the actor in pretty much
  everything that might need to be done

  figuring out whether to regenerate or remove expired certs requires
  some of the same data as crl generation

- tiny up-down root server -- no sql or left-right needed, just config
  file, http server, static root cert and key.  in theory this should
  just be a matter of subtyping the main up-down code while overriding
  the serve_pdu() methods.

  things we'd need in a config file for this:

  - the one and only issuer cert (self-signed in this special case)
  - the one and only issuer private key id
  - filename in which to store the one and only subject cert
  - bsc info for one and only child
  - https server key and cert
  - validity interval to use when issuing
  - publication urls for issuer cert, subject cert, crl, and manifest
  - https and cms data for publication server
  - resources to issue?  or just copy/inherit from self-signed?

- Haven't done anything about db.commit() and db.rollback() yet, for
  that matter haven't yet whacked MySQL to enable those features.

- Access to object data attributes really ought to be through accessor
  methods so that the .set() method can set the sql_dirty flag
  automagically.  Not done yet.

- Hmm, I seem to have goofed on the bsc table, need a column for the
  hash algorithm after all, as it's not intrinsic to the key.  Probably
  ought to let it be set independently of the key too.  But for the
  moment I'm only supporting 2048-bit RSA with SHA-256 digests, so
  fixing this is not urgent.



Further to do items from email dated 8 November 2007 (need to fold
this into the above list and clean it up for others to read):

- Hack some kind of stub publication (not real protocol yet, just dump
  to local filesystem so can see outputs and maybe rcynic against
  them); this is a stop-gap to let me concentrate on the main engine
  and defer work on the publication protocol and engine.

- Whack expiration dates of certs to match irdb valid_until value when
  issuing -- valid_until is optional, what do we do if it's not set?
  Default period in self object seems obvious answer, neither Randy
  nor I has thought of anything better yet.

- Code to clean up expired certs

- Code to revoke certs -- need to sort out when we do this
  automatically vs waiting for explicit revoke PDU from child

- Code to generate CRLs

- Test with larger data set -- Tim gave me plenty of data and I have
  the low-level tools, just haven't written the glue logic to create
  child objects for all the entities in the IRDB, poll on behalf of
  each of them, and check the result for sanity

Once this lot is done we'll be close to something that shows at least
the basics of normal operation, albiet in a form that's not yet usable
in production.

Follow-up after that will be getting rid of remaining synchronous code
(make daemon fully event-driven, except perhaps for SQL queries),
address rollback, commit, and other data integrity issues, and see how
well the resulting code handles hosting (multiple self objects in same
daemon).

Somewhere along the way I'll need to update to the new model of trust
anchors we ended up with in Amsterdam, first step for which will
involve writing it down (well, RobK was supposed to do that, but I was
supposed to convert some pencil sketches into graphviz for him so
we're both lame on this so far).
